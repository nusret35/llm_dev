18.409 An Algorithmist‚Äôs Toolkit 10/29/09 
Lecture 14 
Lectur er: Jonathan Kelner 
1 Appro ximating the volume of a con vex body 
Exactly computing the volume a convex body is known to be #P-hard, so the fact that we can approximate 
its volume in P is surprising‚Äìthe kind of result you would bet against until you saw it was true. 
Before discussing any algorithms, though, we need to say what it means to be given a convex body K. 
To keep our implemen tation as general as possible, we‚Äôll assume that K is given by some oracle: 
1. Membership oracle
Given a point p, returns ‚Äôyes‚Äô if p ‚àà K and ‚Äôno‚Äô if p ‚àà/K.
2. Separation oracle
Given a point p, returns ‚Äôyes‚Äô if p ‚àà K and a separating hyperplane H if p /negationslash‚ààK.
Given a reasonable description of a convex body, it is easy to build a separation oracle. For example, 
1. A ball of radius r 
Given p, compute its norm |p|. If less than r, return ‚Äôyes‚Äô; if greater than r, return the hyperplane 
tangen t to the boundary sphere at rp/|p|. 
2. A cube of side length s 
Given p, compute its l‚àû norm. If less than s/2, return ‚Äôyes‚Äô; if greater, return the face of the cube in 
the violated direction. 
3. A polytop e 
Given p, check each inequalit y. If it satisÔ¨Åes them all, return ‚Äôyes‚Äô; if not, return the failed inequalit y. 
In what follows, we‚Äôll assume that our convex body contains a ball of radius 1 centered at the origin, and 
is contained within a ball of radius 2poly(n). These conditions are reasonable‚Äìafter suitable translation and 
dilation, they hold for any K speciÔ¨Åed by inequalities of polynomial bit length. 
Given a membership oracle, how could we approximate volume? The naive Monte Carlo algorithm‚Äì 
pick points from some designated region (say a ball) and check if they‚Äôre in K‚Äìin general fails. If K is an 
ellipse with major axis of exponential length l and minor axis l‚àí1, then the probabilit y of a successful trial 
is exponentially small. No chance of a polynomial time algorithm. But if the body is well-rounded, say 
B2 n ‚äÜ K ‚äÜ nB2 n, then the following algorithm has a chance: 
1. Pick points p1, ¬∑¬∑¬∑,pm 
2. Check if pi ‚àà K 
3. Set K/prime := conv{pi|pi ‚àà K} 
4. Return the volume of K/prime 
If n = 2, this algorithm works: 
Theorem 1 For any /epsilon1> 0, ther e exists a set P = {p1, ¬∑¬∑¬∑,pm} s.t. m is polynomial in 1//epsilon1 and for any 
well-rounde d 2-dimensional convex body K, Vol(con v(P ‚à©K)) ‚â• Vol(K)/(1 + /epsilon1). 
14-1 For example, a grid with spacing /epsilon1/8 works. In higher dimensions, though, a grid has exponentially many 
points. It‚Äôs also diÔ¨Écult to compute the convex hull of a bunch of points in high dimensions. We could try 
to construct our set of points more carefully , perhaps tailoring them based on our knowledge of the body so 
far. It turns out that such an algorithm cannot succeed. 
Theorem 2 Ther e is no deterministic poly time algorithm that, given a memb ership oracle for K, computes 
Vol(K) within a polynomial factor. 
Pro of Since the algorithm is deterministic, an adversary can construct a worst-case K depending on the 
queries. Her evil plan is to answer ‚Äôyes‚Äô to each query p if p ‚ààB2 n, so at the end of the algorithm, the only data 
nknown about the convex body is that it contains a polynomial number of points P = {p1,...,p m}‚äÇB2 , 
and not certain points outside of the ball. Hence the algorithm cannot distinguish between K1 = B2 n 
and K2 = conv(p1,...,p m). We will show that for any such polynomial collection of points, the ratio 
Vol(K1)/Vol(K2) is exponentially large, dooming our algorithm to defeat. 
For each pi, denote Bi by the ball centered at pi/2 of radius |pi|/2. Now we claim that conv(P) ‚äÜ Bi. 
We can rewrite Bi as {x|‚à†pixO ‚â•œÄ/2}. Let v ‚ààpipj . We‚Äôll show that Bv ‚äÇBi ‚à™Bj , where Bv is the ball 
centered at v/2 of radius |v|/2. For any point x ‚ààBv,wehave ‚à†vxO ‚â•œÄ/2. We consider three cases: 
1.	x ‚àà/triangleOpipj . Then ‚à†Oxpi + ‚à†Oxpj + ‚à†pj xpi =2œÄ gives ‚à†Oxpi + ‚à†Oxpj ‚â•œÄ, and one angle must be 
at least œÄ/2. 
2.	x is outside the triangle in the pi direction, so ‚à†Oxpi ‚â•‚à†Oxv ‚â•œÄ/2 
3.	x is outside the triangle in the pj direction, so ‚à†Oxpj ‚â•‚à†Oxv ‚â•œÄ/2 
Hence Bv ‚äÇ Bi for any v in the boundary of the convex hull of the pi. Since any x ‚ààconv(P) is a 
linear combination of two points v, w on the boundary , x ‚ààBx ‚äÇBv ‚à™Bw ‚äÇBi. Hence the volume of the 
convex hull is at most m mconv(Vol(P)) ‚â§ÔøΩ 
Vol(Bi) ‚â§ 2n Vol(B2 n). 
i=1 
One can show that separation oracles are also insuÔ¨Écien t for creating a deterministic polynomial time 
algorithm. It is worth noting that, together with our randomized algorithm for approximating the volume 
of a convex body, we have proved that the separation oracle A separates P from BPP, i.e., PA =/negationslash BPPA . 
But it is widely believed that P = BPP. What‚Äôs going on? There exist bodies without polynomial time 
separation oracles. 
2 The Algorithm 
We will give a randomized, polynomial time algorithm for approximating the volume of a convex body, given 
a separation oracle. The presen tation roughly follows the original Dyer, Frieze, Kannan paper, and gives a 
very bad polynomial (degree ‚âà30). There are now algorithms running in O(n4). The strategy is similar to 
the one we used to approximate the permanen t, Ô¨Ånding a nested sequence of sets where random sampling 
hits with polynomial probabilit y, and then multiplying the ratios. 
Given a method for sampling from a convex body, we can implemen t the following (sketched) algorithm: 
1. Change coordinates so that K is well-rounded , B ‚äÜK ‚äÜnB 
i2. Let œÅ =1+1/n, and let Ki = K ‚à©œÅB. Compute 
Vol(Ki‚àí1)Œ≥i = Vol(Ki) 
14-2 3. Return Vol(B) ÔøΩ Œ≥i 
The Ô¨Årst step can be done with the separating oracle and the ellipsoid algorithm, or the metho d on the 
problem set. The last step works since K0 = K ‚à©B = B and KN = K ‚à©nB = K. For the second step, we 
need to sample. It‚Äôs easy to sample from highly symmetric objects: the cube is given by n uniforms, U[0, 1], 
the sphere by n gaussians, appropriately rescaled, the ball by picking the direction, then the radius. For 
nonsymmetric bodies, the best bet is a random walk. There are a few ways walk: 
1.	Grid Walk
Intersect a grid with the body; walk on the resulting graph.
2.	Ball Walk
At a point p, pick a random neighbor in a small ball centered at p, and walk there.
3.	Hit and Run
At a point p, draw a random line l through p and walk to a random point l ‚à©K.
We‚Äôll use the grid walk. Drop a width Œ¥ grid on R, the graph H with vertices Œ¥Zn with edges p ‚Üíp ¬±Œ¥ei, 
and set G = H ‚à©K. We can walk on G using a membership oracle; walk on H, and if you would go to a 
neighbor not in G, choose again. Note that H has degree 2n, but exponentially many vertices, so we need 
to show that the walk mixes very quickly. This is plausible though, and is easily seen when G is just a 
cube with side length ‚â§n/Œ¥. Since the path Pn/Œ¥ mixes in time polynomial in n/Œ¥, and the cube is just the 
product P n, its mixing time is n times that of the path, so still polynomial. There are still many problems 
with using a the walk on G to approximate K. 
1. We‚Äôre only sampling lattice points. After walk mixes, we could take a random vector v from the cube 
of width Œ¥ centered at p ‚ààG. But if p + v ‚àà/K, we‚Äôre in trouble. We could throw it out and re-sample, 
but this would overweight points near the boundary . Alternativ ely, we could start the whole walk over, 
which is acceptable as long as the probabilit y of landing outside is small. 
2. The graph might be (close to) bipartite. Just use the lazy walk. 
3. The graph has nonconstan t degree. Throw in self-lo ops for vertices near boundary .	Equiv alently, our 
walk is: pick a random vector v ‚àà¬±ei;if p + v ‚ààK, go there, otherwise, stay put. 
4. The graph G might not be connected! If K has a sharp angle, then the vertex of G closest to the 
corner will not be adjacen t to any other vertices of G. Finer grids don‚Äôt help, as this is a problem with 
the angle itself. 
We‚Äôll Ô¨Åx the last problem next lecture, by walking on the graph G associated to K/prime =(1+ /epsilon1)K. 
14-3 MIT OpenCourseWare
http://ocw.mit.edu 
18.409  Topics in Theoretical Computer Science: An Algorithmist's Toolkit 
Fall 2009 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms . 