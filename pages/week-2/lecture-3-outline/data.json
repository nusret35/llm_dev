
{
  "title":"Lecture 3 Outline",
  "content":" Previously Modularity reduces complexity. Naming is necessary for modularity. Operating Systems Job: Enforce modularity on a single machine. Also: Multiplexing, isolation, cooperation, portability, performance, \u0026hellip; To enforce modularity on a single machine, need to: Protect programs\u0026rsquo; memory from each other. Allow programs to communicate. Allow programs to share a single CPU. Virtualization is how we do that. Today: Virtualize memory. Assume one CPU per program and that programs don\u0026rsquo;t need to communicate. Virtual Memory Two components: Main memory, CPU. CPU holds instruction pointer (EIP). Naive method: Two programs can just point to each other\u0026rsquo;s memory (bad). Another method: Force programs to only use particular blocks of memory by having them address only part of the space. Complicated. Virtual memory addressing: Let each program address the full 32-bit space. MMU translates virtual to physical addresses. Page Tables Idea 1: Store physical addresses, use virtual addresses as an index into that table. Problem: Table is too big. Solution: Virtual address = page number + offset. MMU maps virtual page numbers to physical page numbers. Keeps offset the same. Page table entries contain other stuff. Among that stuff: Present bit This bit lets us know if a page resides in RAM or storage. That\u0026rsquo;s how the OS deals with not actually having 2^32* (number of programs) physical addresses in RAM: Pages can live on disk when necessary. R/W bit U/S bit These bits let the OS know when to trigger page faults. Hierarchical Page Tables \u0026ldquo;Normal\u0026rdquo; page tables (described above) still use a lot of space. Page tables have to be allocated all at once or not at all. Hierarchical page tables solve this by creating a hierarchy of page tables and allocating each table only when it\u0026rsquo;s needed. Virtual addresses get divided into multiple parts, one part per level in the hierarchy + an offset. Downside? Speed. Multiple lookups instead of one. More page faults. Kernel Virtualized memory doesn\u0026rsquo;t protect the page table. Kernel mode vs. user mode does this. Switch between user and kernel modes via interrupts. Abstraction Some things can\u0026rsquo;t be virtualized (disk, network, \u0026hellip;). OS abstractions (system calls) make these things portable. System calls are implemented as interrupts. Virtual Memory as Naming Virtual memory is just a naming scheme. Gives us hiding, controlled sharing, indirection. Next lectures: Get rid of our initial assumptions (one CPU per program, etc.).\n"}


