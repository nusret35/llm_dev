
{
  "title":"Lecture 4 Outline",
  "content":" Previously We\u0026rsquo;re on a quest to enforce modularity on a single machine. Last time: Virtualize memory to prevent programs from accessing each other\u0026rsquo;s memory. This time: Virtualize communication links to allow programs to communicate. Still assuming one program per CPU, and a correct kernel. Bounded Buffers Allow programs to communicate. Another application of virtualization. Stores N messages, to deal with bursts. API: send(m), m \\\\\u0026lt;- receive() Receivers and senders block if there are no messages (receiver) or no space (sender). Concurrency causes problems in the implementation. Need to decide when it\u0026rsquo;s okay to write, when it\u0026rsquo;s okay to read, and where to write to/read from. Bounded Buffers for Single Senders send(bb, message): \u0026amp;nbsp;\u0026amp;nbsp;while True: # Wait until it's okay to write \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;if bb.in – bb.out \u0026lt; N: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;bb.buf[bb.in mod N] \u0026lt;- message \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;bb.in \u0026lt;- bb.in + 1 \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;return receive(bb): \u0026amp;nbsp;\u0026amp;nbsp;while True: # Wait until it's okay to read \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;if bb.out \u0026lt; bb.in: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;message \u0026lt;- bb.buf[bb.out mod N] \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;bb.out \u0026lt;- bb.out + 1 \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;return message Can\u0026rsquo;t swap the action and the increment; can cause reads of messages that don\u0026rsquo;t exist. Bounded Buffer for Multiple Senders With two senders, different orders of executions will lead to unexpected output in the previous implementation (empty slots in the buffer, too few elements in the buffer). Need locks. Locks Allow only one CPU to be in a piece of code at a time. API: acquire(lock), release(lock) *Not* acquire(variable I want to lock) If two CPUs try to acquire the same lock at the same time, one will succeed and the other will block. Bounded Buffers with Locks Attempt 1 (using pseudocode): Locks around every line. send(int x) { \u0026amp;nbsp;\u0026amp;nbsp;acquire(\u0026amp;lck); \u0026amp;nbsp;\u0026amp;nbsp;buf[in] = x; \u0026amp;nbsp;\u0026amp;nbsp;release(\u0026amp;lck); \u0026amp;nbsp;\u0026amp;nbsp;acquire(\u0026amp;lck); \u0026amp;nbsp;\u0026amp;nbsp;in = in + 1; \u0026amp;nbsp;\u0026amp;nbsp;release(\u0026amp;lck); } Result: Correct number of elements, but some slots have no messages (A and B write to same slot, and both increment). Attempt 2: send(int x) { \u0026amp;nbsp;\u0026amp;nbsp;acquire(\u0026amp;lck); \u0026amp;nbsp;\u0026amp;nbsp;buf[in] = x; \u0026amp;nbsp;\u0026amp;nbsp;in = in + 1; \u0026amp;nbsp;\u0026amp;nbsp;release(\u0026amp;lck); } Correct: We want write and increment to be atomic (happen together). Back to original code. Attempt 1: send(bb, message): \u0026amp;nbsp;\u0026amp;nbsp;while True: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;if bb.in — bb.out \u0026lt; N: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;acquire(bb.lock) \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;bb.buf[bb.in mod N] \u0026lt;- message \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;bb.in \u0026lt;- bb.in + 1 \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;release(bb.lock) \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;return No: Concurrent senders will both think they can write, the first to acquire the lock might fill up the buffer (and so the second shouldn\u0026rsquo;t write). Attempt 2: send(bb, message): \u0026amp;nbsp;\u0026amp;nbsp;acquire(bb.lock) \u0026amp;nbsp;\u0026amp;nbsp;while True: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;if bb.in — bb.out \u0026lt; N: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;bb.buf[bb.in mod N] \u0026lt;- message \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;bb.in \u0026lt;- bb.in + 1 \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;release(bb.lock) \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;return If the receiver is also trying to acquire lock, this attempt will prevent the receiver from ever receiving (so the sender will keep blocking when the buffer is full). If the receiver is using a different lock we will face issues with concurrently editing the same data structure. Attempt 3 (correct): send(bb, message): \u0026amp;nbsp;\u0026amp;nbsp;acquire(bb.lock) \u0026amp;nbsp;\u0026amp;nbsp;while bb.in - bb.out = N: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;release(bb.lock) // repeatedly release and acquire, to allow \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;acquire(bb.lock) // processes calling receive() to jump in \u0026amp;nbsp;\u0026amp;nbsp;bb.buf[bb.in mod N] \u0026lt;- message \u0026amp;nbsp;\u0026amp;nbsp;bb.in \u0026lt;- bb.in + 1 \u0026amp;nbsp;\u0026amp;nbsp;release(bb.lock) \u0026amp;nbsp;\u0026amp;nbsp;return Atomic Actions How to decide what should make up an atomic action? Too much code in locks: Performance suffers. Too little code in locks: Unexpected behavior. Think of locks as protecting an invariant. Don\u0026rsquo;t release the lock when the invariant is false. Example: Locks for file systems Filesystem move: move(dir1, dir2, filename): \u0026amp;nbsp;\u0026amp;nbsp;unlink(dir1, filename) \u0026amp;nbsp;\u0026amp;nbsp;link(dir2, filename) Coarse-grained locking: move(dir1, dir2, filename): \u0026amp;nbsp;\u0026amp;nbsp;acquire(fs_lock) \u0026amp;nbsp;\u0026amp;nbsp;unlink(dir1, filename) \u0026amp;nbsp;\u0026amp;nbsp;link(dir2, filename) \u0026amp;nbsp;\u0026amp;nbsp;release(fs_lock) Bad performance: can\u0026rsquo;t move two different files between entirely different directories at the same time. Fine-grained locking: move(dir1, dir2, filename): \u0026amp;nbsp;\u0026amp;nbsp;acquire(dir1.lock) \u0026amp;nbsp;\u0026amp;nbsp;unlink(dir1, filename) \u0026amp;nbsp;\u0026amp;nbsp;release(dir1.lock) \u0026amp;nbsp;\u0026amp;nbsp;acquire(dir2.lock) \u0026amp;nbsp;\u0026amp;nbsp;link(dir2, filename) \u0026amp;nbsp;\u0026amp;nbsp;release(dir2.lock) Better performance, but incorrect. What if dir2 is renamed between release and acquire? Bad because CPU sees inconsistent state. Fine-grained locking + holding both locks move(dir1, dir2, filename): \u0026amp;nbsp;\u0026amp;nbsp;acquire(dir1.lock) \u0026amp;nbsp;\u0026amp;nbsp;acquire(dir2.lock) \u0026amp;nbsp;\u0026amp;nbsp;unlink(dir1, filename) \u0026amp;nbsp;\u0026amp;nbsp;link(dir2, filename) \u0026amp;nbsp;\u0026amp;nbsp;release(dir1.lock) \u0026amp;nbsp;\u0026amp;nbsp;release(dir2.lock) Deadlock when A does move(M, N, file1.txt), B does move(N, M, file2.txt). Fine-grained locking + solving deadlock Heuristic: Look for all places where multiple locks are held, and ensure that locks are acquired in the same order. move(dir1, dir2, filename): \u0026amp;nbsp;\u0026amp;nbsp;if dir1.inum \u0026lt; dir2.inum: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;acquire(dir1.lock) \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;acquire(dir2.lock) \u0026amp;nbsp;\u0026amp;nbsp;else: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;acquire(dir2.lock) \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;acquire(dir1.lock) \u0026amp;nbsp;\u0026amp;nbsp;unlink(dir1, filename) \u0026amp;nbsp;\u0026amp;nbsp;link(dir2, filename) \u0026amp;nbsp;\u0026amp;nbsp;release(dir1.lock) \u0026amp;nbsp;\u0026amp;nbsp;release(dir2.lock) Painful: Requires global reasoning about all locks. Answer? Start coarse-grained and refine. Implementing Locks Attempt 1: acquire(lock): \u0026amp;nbsp;\u0026amp;nbsp;while lock != 0: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;do nothing \u0026amp;nbsp;\u0026amp;nbsp;lock = 1 release(lock): \u0026amp;nbsp;\u0026amp;nbsp;lock = 0 Race condition: Both see lock = 0, set lock = 1, and execute code. Problem: Need locks to implement locks. Solution: Hardware support (atomic instructions). x86 example: XCHG XCHG reg, addr \u0026amp;nbsp;\u0026amp;nbsp;temp \u0026lt;- mem[addr] \u0026amp;nbsp;\u0026amp;nbsp;mem[addr] \u0026lt;- reg \u0026amp;nbsp;\u0026amp;nbsp;reg \u0026lt;- temp Now: acquire(lock): \u0026amp;nbsp;\u0026amp;nbsp;do: \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;r \u0026lt;= 1 \u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;XCHG r, lock \u0026amp;nbsp;\u0026amp;nbsp;while r == 1 Atomic operations made possible by the controller that manages access to memory. "}


